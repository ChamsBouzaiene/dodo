package editing

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestSearchReplace_Basic(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "test.txt"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "Hello World\nThis is a test.\nGoodbye World"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test
	oldString := "This is a test."
	newString := "This is a REPLACEMENT."
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected success, got failure: %s", resultJSON)
	}

	newContentBytes, err := os.ReadFile(fullPath)
	if err != nil {
		t.Fatal(err)
	}
	newContent := string(newContentBytes)
	expectedContent := "Hello World\nThis is a REPLACEMENT.\nGoodbye World"
	if newContent != expectedContent {
		t.Errorf("expected content:\n%s\ngot:\n%s", expectedContent, newContent)
	}
}

func TestSearchReplace_ReplaceAll(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "test.txt"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "foo bar foo bar foo"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test
	oldString := "foo"
	newString := "baz"
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, true)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected success, got failure: %s", resultJSON)
	}

	newContentBytes, err := os.ReadFile(fullPath)
	if err != nil {
		t.Fatal(err)
	}
	newContent := string(newContentBytes)
	expectedContent := "baz bar baz bar baz"
	if newContent != expectedContent {
		t.Errorf("expected content:\n%s\ngot:\n%s", expectedContent, newContent)
	}
}

func TestSearchReplace_NotFound(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "test.txt"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "Hello World"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test
	oldString := "Goodbye"
	newString := "Bye"
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if !strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected failure, got success: %s", resultJSON)
	}
	if !strings.Contains(resultJSON, "old_string not found") {
		t.Errorf("expected 'old_string not found' error, got: %s", resultJSON)
	}
}

func TestSearchReplace_NotFound_WhitespaceHint(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "test.txt"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "func foo() {\n\treturn true\n}"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test with spaces instead of tabs
	oldString := "func foo() {\n    return true\n}"
	newString := "func bar() {}"
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if !strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected failure, got success: %s", resultJSON)
	}
	// This assertion expects the improvement to be implemented
	// It might fail initially, which is expected
	if !strings.Contains(resultJSON, "whitespace mismatch") && !strings.Contains(resultJSON, "Indentation mismatch") {
		t.Logf("Note: whitespace hint not yet implemented or message differs. Got: %s", resultJSON)
	}
}

func TestSearchReplace_Ambiguous(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "test.txt"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "foo\nbar\nfoo"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test without replace_all
	oldString := "foo"
	newString := "baz"
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if !strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected failure, got success: %s", resultJSON)
	}
	if !strings.Contains(resultJSON, "old_string appears 2 times") {
		t.Errorf("expected 'old_string appears 2 times' error, got: %s", resultJSON)
	}
}

func TestSearchReplace_Generated(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "gen.go"
	fullPath := filepath.Join(tmpDir, filePath)
	content := "// Code generated by tool. DO NOT EDIT.\npackage main\nfunc foo() {}"
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// Test
	oldString := "func foo() {}"
	newString := "func bar() {}"
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, oldString, newString, false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if !strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected failure, got success: %s", resultJSON)
	}
	if !strings.Contains(resultJSON, "generated") {
		t.Errorf("expected 'generated' error, got: %s", resultJSON)
	}
}

func TestSearchReplace_Binary(t *testing.T) {
	// Setup
	tmpDir := t.TempDir()
	filePath := "image.png"
	// Just create a dummy file, content doesn't matter as extension check happens first
	if err := os.WriteFile(filepath.Join(tmpDir, filePath), []byte("fake png"), 0644); err != nil {
		t.Fatal(err)
	}

	// Test
	resultJSON, err := searchReplaceImpl(tmpDir, filePath, "fake", "real", false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify
	if !strings.Contains(resultJSON, `"status":"failed"`) {
		t.Errorf("expected failure, got success: %s", resultJSON)
	}
	if !strings.Contains(resultJSON, "File type not allowed") {
		t.Errorf("expected 'File type not allowed' error, got: %s", resultJSON)
	}
}
