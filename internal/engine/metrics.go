package engine

import (
	"fmt"
	"sync"
	"time"
)

// AgentMetrics tracks performance metrics for agent execution.
type AgentMetrics struct {
	mu              sync.Mutex
	StartTime       time.Time
	EndTime         time.Time
	TotalSteps      int     // Agent turns (LLM calls)
	TotalToolCalls  int     // Total tool invocations
	InputTokens     int     // Tokens sent to LLM
	OutputTokens    int     // Tokens generated by LLM
	CachedTokens    int     // Cached tokens (Anthropic only)
	EstimatedCost   float64 // USD
	ModelName       string
	Provider        string // "openai", "anthropic", etc.
	ToolCallsByName map[string]int
}

// Global metrics instance (set by NewAgentMetrics)
var globalMetrics *AgentMetrics

// NewAgentMetrics creates a new metrics tracker and sets it as the global instance.
func NewAgentMetrics(provider, modelName string) *AgentMetrics {
	m := &AgentMetrics{
		StartTime:       time.Now(),
		ModelName:       modelName,
		Provider:        provider,
		ToolCallsByName: make(map[string]int),
	}
	globalMetrics = m
	return m
}

// GetGlobalMetrics returns the global metrics instance (or nil if not set).
func GetGlobalMetrics() *AgentMetrics {
	return globalMetrics
}

// RecordStep increments the step counter.
func (m *AgentMetrics) RecordStep() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.TotalSteps++
}

// RecordToolCall increments tool call counters.
func (m *AgentMetrics) RecordToolCall(toolName string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.TotalToolCalls++
	m.ToolCallsByName[toolName]++
}

// RecordTokens updates token counts and recalculates cost.
func (m *AgentMetrics) RecordTokens(input, output, cached int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.InputTokens += input
	m.OutputTokens += output
	m.CachedTokens += cached
	m.EstimatedCost = m.calculateCost()
}

// Finish marks the end time.
func (m *AgentMetrics) Finish() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.EndTime = time.Now()
}

// Duration returns the elapsed time.
func (m *AgentMetrics) Duration() time.Duration {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.EndTime.IsZero() {
		return time.Since(m.StartTime)
	}
	return m.EndTime.Sub(m.StartTime)
}

// calculateCost estimates the cost based on provider and model.
// Must be called with mutex locked.
func (m *AgentMetrics) calculateCost() float64 {
	var inputCostPer1M, outputCostPer1M, cachedCostPer1M float64

	switch m.Provider {
	case "openai":
		switch m.ModelName {
		case "gpt-4o":
			inputCostPer1M = 2.50
			outputCostPer1M = 10.00
		case "gpt-4o-mini":
			inputCostPer1M = 0.15
			outputCostPer1M = 0.60
		case "gpt-3.5-turbo":
			inputCostPer1M = 0.50
			outputCostPer1M = 1.50
		default:
			inputCostPer1M = 0.15
			outputCostPer1M = 0.60
		}
		cachedCostPer1M = inputCostPer1M // OpenAI doesn't have separate cached pricing

	case "anthropic":
		switch m.ModelName {
		case "claude-3-5-sonnet-20241022", "claude-3-5-sonnet-latest", "claude-sonnet-4-5-20250929":
			inputCostPer1M = 3.00
			outputCostPer1M = 15.00
			cachedCostPer1M = 0.30 // 90% discount for cached
		case "claude-3-sonnet-20240229":
			inputCostPer1M = 3.00
			outputCostPer1M = 15.00
			cachedCostPer1M = 0.30
		default:
			inputCostPer1M = 3.00
			outputCostPer1M = 15.00
			cachedCostPer1M = 0.30
		}

	case "kimi":
		// BytePlus ModelArk pricing for Kimi K2
		// Source: https://docs.byteplus.com/en/docs/modelark/1747867
		// Official pricing as of 2025
		switch m.ModelName {
		case "kimi-k2-250711", "kimi-k2-250905", "kimi-k2":
			// Official pricing from BytePlus docs
			inputCostPer1M = 0.60            // $0.60 per 1M input tokens
			outputCostPer1M = 2.50           // $2.50 per 1M output tokens
			cachedCostPer1M = inputCostPer1M // No separate cached pricing info available
		default:
			inputCostPer1M = 0.60
			outputCostPer1M = 2.50
			cachedCostPer1M = 0.60
		}

	default:
		// Unknown provider
		return 0.0
	}

	// Calculate cost
	inputCost := float64(m.InputTokens-m.CachedTokens) * inputCostPer1M / 1_000_000
	cachedCost := float64(m.CachedTokens) * cachedCostPer1M / 1_000_000
	outputCost := float64(m.OutputTokens) * outputCostPer1M / 1_000_000

	return inputCost + cachedCost + outputCost
}

// String returns a human-readable summary.
func (m *AgentMetrics) String() string {
	m.mu.Lock()
	defer m.mu.Unlock()

	duration := m.Duration()

	summary := fmt.Sprintf(`
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š Agent Metrics Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Model:        %s (%s)
Duration:     %s
Steps:        %d agent turns
Tool Calls:   %d total
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Tokens:
  Input:      %d
  Output:     %d
  Cached:     %d (%.1f%% of input)
  Total:      %d
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Cost:         $%.4f USD
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,
		m.ModelName,
		m.Provider,
		duration.Round(time.Millisecond),
		m.TotalSteps,
		m.TotalToolCalls,
		m.InputTokens,
		m.OutputTokens,
		m.CachedTokens,
		float64(m.CachedTokens)/float64(max(m.InputTokens, 1))*100,
		m.InputTokens+m.OutputTokens,
		m.EstimatedCost,
	)

	// Add top tools if any
	if len(m.ToolCallsByName) > 0 {
		summary += "\n\nTop Tools:\n"
		type toolCount struct {
			name  string
			count int
		}
		var tools []toolCount
		for name, count := range m.ToolCallsByName {
			tools = append(tools, toolCount{name, count})
		}
		// Sort by count descending (simple bubble sort for small lists)
		for i := 0; i < len(tools); i++ {
			for j := i + 1; j < len(tools); j++ {
				if tools[j].count > tools[i].count {
					tools[i], tools[j] = tools[j], tools[i]
				}
			}
		}
		for i, tc := range tools {
			if i >= 5 { // Show top 5
				break
			}
			summary += fmt.Sprintf("  %d. %s (%dx)\n", i+1, tc.name, tc.count)
		}
	}

	summary += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
	return summary
}

// CompactString returns a compact one-line summary.
func (m *AgentMetrics) CompactString() string {
	m.mu.Lock()
	defer m.mu.Unlock()

	duration := m.Duration()
	return fmt.Sprintf("Steps: %d | Tools: %d | Time: %s | Tokens: %d in + %d out | Cost: $%.4f",
		m.TotalSteps,
		m.TotalToolCalls,
		duration.Round(time.Millisecond),
		m.InputTokens,
		m.OutputTokens,
		m.EstimatedCost,
	)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
